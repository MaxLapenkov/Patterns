// WebWorkers
// Особенности
Работают в отдельном от основного JS кода потоке, что позволяет улучшить производительность при использовании сложных вычислений
// Выделенные воркеры (Dedicated Workers)
К таким воркерам есть доступ только у скрипта, крирпый вызвал его.
// Разделяемые воркеры (Shared Workers)
К таким воркерам может быть доступ у нескольких окон, iframes и других воркеров
// Способы отправки сообщений в web workers
myWorker.port.postMessage([first.value, second.value
// Обработка ошибок
const mySharedWorker = new SharedWorker('shared-worker.js');

mySharedWorker.onerror = (event) => {
  console.error('There is an error with your worker!');

// Импорт скриптов и библиотек

Worker потоки имеют доступ к глобальной функции, importScripts(), которая позволяет импортировать скрипты с того же домена в их область видимости. Функция принимает ноль и более URI параметров, как список ссылок на ресурсы для импорта; все нижеприведённые примеры верны:

importScripts();                        /* imports nothing */
importScripts('foo.js');                /* imports just "foo.js" */
importScripts('foo.js', 'bar.js');      /* imports two scripts */

// Service workers
// Регистрация сервис воркера?
navigator.serviceWorker.register('service-worker.js', {
    scope: './'
})
// Scope? Можно ли установить несколько сервис воркеров с разными scope? Что если в scope передать одинаковые урлы для двух разных сервис воркеров?
Можно. Каждый worker будет перехватывать запросы только в своем scope. Если передать одинаковые URL, то будет использован только один сервис воркер
// Почему нет доступа к синхронным браузерным API?
Он находится между браузером и интернетом и может лишь перехватывать запросы и взаимодействовать с ответами.
// Жизненный цикл у сервис-воркера? На какие события можно подписаться в нем? Что происходит на каждом событии?
Registration - происходит загрузка сервис воркера после полной загрузки страницы,
Installation - установка происходит только один раз для каждого service worker. Можно отследить установку с помощью addEventListener. В этот момент можно закешировать оболочку приложения.
Activation - Происходит если registration и activation прошли успешно. Также можно отследить с помощью addEventListener. В этот момент обычно очищается старый кеш.
// Кешировать полученных данных?
При возникновении события fetch при помощи addEventListener Можно кешировать данные запросов.
// Как необходимо проводить переустановку сервис воркера на более новый? В какой момент новый сервис воркер начинает работать? Как можно пропустить фазу ожидания обновления?
Нужно поменять файл воркера, тогда появится новый воркер и передет в фазу ожидания. Чтобы закончилась эта фаза нужно чтобы были закрыты все вкладки приложения и открыта новая вкладка. Либо можно использовать настройку skipWaiting. Тогда фаза ожидания будет пропущена.
// В какие моменты браузер проверяет сервис воркер на наличие обновлений? Можно ли сделать это в ручную?
При полной перезагрузке приложения (все вкладки закрыты и открыта новая). Можно в консоли очистить весь кеш и нажать кнопку skipWaiting.
// Двусторонний обмен сообщениями между сервис воркером и клиентом?
Broadcast Channel API позволяет установить такой обмен
//  Перехват и обработка запросов?
Происходит в событии fetch
// Просмотр установленных сервис воркеры?
В dev tools
// dev tools для работы с сервис воркерами?
В хроме самый удобные, на вкладке application
// Worklets. Процесс рендеринга html-страницы
Это интерфейсы для облегченной версии web-воркеров. они дают доступ к низкоуровневым частям процесса рендеринга. Они используются только для специфических use-cases.
PaintWorklet, AudioWorklet, AnimationWorklet, LayoutWorklet
// Библиотеки и поддержка воркеров в React/Angular/Vue
workbox